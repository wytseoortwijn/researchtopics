\chapter{Motivation}

Model checking is an important tool in software verification. Model checking can be used check if the model of a software system meets its requirements. A model checker can be implemented in various ways, one of which is symbolically \cite{mcmillan1993symbolic, clarke1996symbolic}. Rather than explicitly maintaining states, a symbolic model checker stores the state space as a Boolean formula, represented as a \emph{Binary Decision Diagram (BDD)}. The main advantage of such a representation is that a small Boolean function can potentially represent a large number of states, thus giving an efficient representation of the state space. Symbolic model checking has already been widely used as a verification tool and a fair number of symbolic model checkers already exist \cite{cimatti2000nusmv, marrying}. 

\section{Early Work}
In the early 90's a lot of research has been done on parallel BDD manipulation using massively parallel computers \cite{BDDNOW:parallel_bdd_package, 545652, Stornetta96implementationof, BDDNOW:parallel_bdd_package}. Most work was designed for SIMD machines and vector machines. Researches experimented with different ways to partition work, including BFS, DFS, nested DFS, and hybrid DFS/BFS. In the late 90s research attention shifted towards distributed BDD manipulation. At that time, a network of workstations was the most affordable and best available parallel platform, which motivated the research for distributed BDD manipulation \cite{BDDNOW:parallel_bdd_package}. Experimental results pointed out that very large BDDs could be manipulated due to the aggregated memory of the network, but speedups were not obtained. This was mainly due to network latency, which was the major performance bottleneck. The best results were obtained by the BDD package BDDNOW \cite{BDDNOW:parallel_bdd_package}, which only achieved some speedup when the sequential implementation ran out of main-memory and disk-based storage was used instead.

After the 90s research attention shifted towards the use of BDDs in shared and distributed memory rather than parallel or distributed manipulation of BDDs.

\section{Recent Work}
Hardware changed significantly during the last decade. At the time of writing, parallel hardware is widely available and specialized high performance network interconnects like Infiniband are just as affordable as standard Ethernet hardware. This justifies a renewed attempt to parallelize and distribute BDD operations. One example of this is Sylvan \cite{sylvan_multicore_bdd}, an implementation of parallel BDD operations by using a lockless hash table and a work stealing framework. Sylvan obtained impressive speedups.

This research project attempts to implement BDD operations on a cluster of multicore machines using RDMA-enabled hardware. By doing that, BDD operations can potentially be designed that scale both across the number of CPU cores and the number of participating machines. To our knowledge, this has never been done before.

\section{Project Relevance}
One of the main problems of model checking today is the \emph{state space explosion} problem. A state space explosion occurs when the amount of information the model checker has to examine does not fit into the available memory. Fighting the state space explosion problem is important, because the amount of information that model checkers have to examine also grows every year. 

There are several ways to tackle this problem, including state space reduction and state space minimization techniques \cite{pater2011partial, blom2005distributed}. The use of BDDs is one of such techniques, since it allows a compact representation of the state space. Nonetheless, the state space explosion problem still exists. 

Another way to tackle the state space explosion problem is to increase the available hardware resources. This can be either the increase in memory, the increase in CPU power or both. Manycore computers are very expensive, whereas a cluster of workstations could be cheaper, depending on the size of the cluster.

Earlier attempts to use a cluster for BDD manipulations have shown that larger BDDs can be constructed, compared to BDD construction on a single machine. On the other hand, speedup is only achieved when the single machine ran out of memory \cite{BDDNOW:parallel_bdd_package}. Still, it is justifiable to reconsider the use of multicore clusters for BDD manipulation, because of the recent hardware advances. If this research succeeds, larger model checking problems can be solved in less time, depending on how well the implementation scales along the different hardware resources. Also other verification algorithms can benefit from this research since they too may scale well across a cluster of machines by applying the same ideas.

The third potential of this research project is the development of heterogeneous algorithms for software verification. It is nowadays possible to use RDMA at the GPU level. So it may be possible to create RDMA-based BDD operations that run anywere, including the GPU \cite{gpudirect}. The development of such algorithms is highly relevant in the field of High Performance Computing, and this research project could potentially form the basis for such development.

To our knowledge, the use of RDMA to implement BDD operations on multicore clusters has never been done before.